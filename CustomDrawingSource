local CustomDrawing = {}
CustomDrawing.__index = CustomDrawing

-- Helper function to find or create the ScreenGui in CoreGui
local function getOrCreateScreenGui()
    local CoreGui = game:GetService("CoreGui")
    local existingGui = CoreGui:FindFirstChild("CustomDrawingGui")
    
    if existingGui then
        return existingGui  -- Reuse the existing ScreenGui
    else
        -- Create the ScreenGui
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "CustomDrawingGui"
        screenGui.Parent = CoreGui
        return screenGui
    end
end

-- CustomDrawing.new("Line", {Transparency = 0.5, Thickness = 3, From = Vector2.new(100, 100), To = Vector2.new(400, 300)})
function CustomDrawing.new(type, options)
    if type == "Line" then
        local self = setmetatable({}, CustomDrawing)

        -- Get or create the ScreenGui in CoreGui
        self.screenGui = getOrCreateScreenGui()

        -- Create the Frame to represent the line
        self.lineFrame = Instance.new("Frame")
        self.lineFrame.AnchorPoint = Vector2.new(0.5, 0.5)
        self.lineFrame.BorderSizePixel = 0
        self.lineFrame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)  -- Red color for visibility (can be changed)
        self.lineFrame.Parent = self.screenGui

        -- Initialize properties (public)
        self.Transparency = options.Transparency or 0  -- Default 0 (fully opaque)
        self.Thickness = options.Thickness or 1        -- Default 1 (smallest thickness)

        -- Ensure From and To are valid Vector2 values (default to (0,0) and (100,100) if nil)
        self.From = options.From or Vector2.new(0, 0)
        self.To = options.To or Vector2.new(100, 100)

        -- Draw the line based on the initial properties
        self:updateLine()

        return self
    else
        error("Unsupported drawing type: " .. tostring(type))
    end
end

-- Update the line based on its properties
function CustomDrawing:updateLine()
    -- Ensure that From and To are valid
    if not self.From or not self.To then
        warn("From or To is nil, skipping update.")
        return
    end

    local deltaX = self.To.X - self.From.X
    local deltaY = self.To.Y - self.From.Y
    local distance = math.sqrt(deltaX * deltaX + deltaY * deltaY)

    -- Update size, position, transparency, and rotation
    self.lineFrame.Size = UDim2.new(0, distance, 0, self.Thickness)
    self.lineFrame.Position = UDim2.new(0, (self.From.X + self.To.X) / 2, 0, (self.From.Y + self.To.Y) / 2)
    self.lineFrame.Rotation = math.deg(math.atan2(deltaY, deltaX))
    self.lineFrame.BackgroundTransparency = self.Transparency
end

-- Create a custom metatable to update properties dynamically
function CustomDrawing:__newindex(key, value)
    if key == "Transparency" then
        rawset(self, key, value)
        self:updateLine()
    elseif key == "Thickness" then
        rawset(self, key, value)
        self:updateLine()
    elseif key == "From" then
        -- Ensure 'From' is a valid Vector2
        if typeof(value) == "Vector2" then
            rawset(self, key, value)
            self:updateLine()
        else
            warn("Invalid value for 'From', must be Vector2")
        end
    elseif key == "To" then
        -- Ensure 'To' is a valid Vector2
        if typeof(value) == "Vector2" then
            rawset(self, key, value)
            self:updateLine()
        else
            warn("Invalid value for 'To', must be Vector2")
        end
    else
        rawset(self, key, value)
    end
end

return setmetatable(CustomDrawing, {__call = CustomDrawing.new})
