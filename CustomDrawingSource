local CustomDrawing = {}
CustomDrawing.__index = CustomDrawing

-- Helper function to get or create a ScreenGui in CoreGui
local function getOrCreateScreenGui()
    local CoreGui = game:GetService("CoreGui")
    local existingGui = CoreGui:FindFirstChild("CustomDrawingGui")
    
    if existingGui then
        return existingGui -- Reuse existing ScreenGui
    else
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "CustomDrawingGui"
        screenGui.Parent = CoreGui
        return screenGui
    end
end

-- Base class for drawing objects
local DrawingObject = {}
DrawingObject.__index = DrawingObject

function DrawingObject.new()
    local self = setmetatable({}, DrawingObject)
    self.screenGui = getOrCreateScreenGui()  -- Reuse or create a ScreenGui
    self.properties = {} -- Store properties here
    return self
end

-- Helper function to set property and trigger an update
local function setPropertyAndUpdate(self, key, value)
    self.properties[key] = value -- Store the property
    if self.update then
        self:update(key) -- Trigger an update for the changed property
    end
end

------------------------------------------------
-- Line class
------------------------------------------------
local Line = {}
Line.__index = Line

function Line.new()
    local self = setmetatable(DrawingObject.new(), Line)

    -- Create the frame for the line
    self.frame = Instance.new("Frame")
    self.frame.AnchorPoint = Vector2.new(0.5, 0.5)
    self.frame.BorderSizePixel = 0
    self.frame.Parent = self.screenGui

    return self
end

function Line:update(changedProperty)
    if self.properties.From and self.properties.To then
        local deltaX = self.properties.To.X - self.properties.From.X
        local deltaY = self.properties.To.Y - self.properties.From.Y
        local distance = math.sqrt(deltaX * deltaX + deltaY * deltaY)

        local midX = (self.properties.From.X + self.properties.To.X) / 2
        local midY = (self.properties.From.Y + self.properties.To.Y) / 2

        self.frame.Size = UDim2.new(0, distance, 0, self.properties.Thickness or 1)
        self.frame.Position = UDim2.new(0, midX, 0, midY)
        self.frame.Rotation = math.deg(math.atan2(deltaY, deltaX))

        if self.properties.Transparency then
            self.frame.BackgroundTransparency = self.properties.Transparency
        end
    end
end

setmetatable(Line, {
    __newindex = function(self, key, value)
        setPropertyAndUpdate(self, key, value)
    end
})

------------------------------------------------
-- Text class
------------------------------------------------
local Text = {}
Text.__index = Text

function Text.new()
    local self = setmetatable(DrawingObject.new(), Text)

    -- Create the text label
    self.label = Instance.new("TextLabel")
    self.label.BackgroundTransparency = 1  -- No background
    self.label.Parent = self.screenGui

    return self
end

function Text:update(changedProperty)
    if self.properties.Text then
        self.label.Text = self.properties.Text
    end
    if self.properties.Size then
        self.label.TextSize = self.properties.Size
    end
    if self.properties.Transparency then
        self.label.TextTransparency = self.properties.Transparency
    end
    if self.properties.Outline and self.properties.OutlineColor then
        self.label.TextStrokeTransparency = 0
        self.label.TextStrokeColor3 = self.properties.OutlineColor
    else
        self.label.TextStrokeTransparency = 1
    end
    if self.properties.Position then
        self.label.Position = UDim2.new(0, self.properties.Position.X, 0, self.properties.Position.Y)
    end
end

setmetatable(Text, {
    __newindex = function(self, key, value)
        setPropertyAndUpdate(self, key, value)
    end
})

------------------------------------------------
-- Circle class
------------------------------------------------
local Circle = {}
Circle.__index = Circle

function Circle.new()
    local self = setmetatable(DrawingObject.new(), Circle)

    -- Create a Frame to simulate the circle using UICorner
    self.frame = Instance.new("Frame")
    self.frame.AnchorPoint = Vector2.new(0.5, 0.5)
    self.frame.BorderSizePixel = 0
    self.frame.Parent = self.screenGui

    -- Add UICorner to round the frame
    local corner = Instance.new("UICorner", self.frame)
    corner.CornerRadius = UDim.new(1, 0)

    return self
end

function Circle:update(changedProperty)
    if self.properties.Radius and self.properties.Position then
        self.frame.Size = UDim2.new(0, self.properties.Radius * 2, 0, self.properties.Radius * 2)
        self.frame.Position = UDim2.new(0, self.properties.Position.X, 0, self.properties.Position.Y)
    end
    if self.properties.Transparency then
        self.frame.BackgroundTransparency = self.properties.Transparency
    end
    if self.properties.Filled == false then
        self.frame.BackgroundTransparency = 1
        if self.properties.Thickness then
            self.frame.BorderSizePixel = self.properties.Thickness
        end
    else
        self.frame.BorderSizePixel = 0
    end
end

setmetatable(Circle, {
    __newindex = function(self, key, value)
        setPropertyAndUpdate(self, key, value)
    end
})

------------------------------------------------
-- Square class
------------------------------------------------
local Square = {}
Square.__index = Square

function Square.new()
    local self = setmetatable(DrawingObject.new(), Square)

    -- Create the frame for the square
    self.frame = Instance.new("Frame")
    self.frame.AnchorPoint = Vector2.new(0.5, 0.5)
    self.frame.BorderSizePixel = 0
    self.frame.Parent = self.screenGui

    return self
end

function Square:update(changedProperty)
    if self.properties.Size and self.properties.Position then
        self.frame.Size = UDim2.new(0, self.properties.Size.X, 0, self.properties.Size.Y)
        self.frame.Position = UDim2.new(0, self.properties.Position.X, 0, self.properties.Position.Y)
    end
    if self.properties.Transparency then
        self.frame.BackgroundTransparency = self.properties.Transparency
    end
    if self.properties.Filled == false then
        self.frame.BackgroundTransparency = 1
        if self.properties.Thickness then
            self.frame.BorderSizePixel = self.properties.Thickness
        end
    else
        self.frame.BorderSizePixel = 0
    end
end

setmetatable(Square, {
    __newindex = function(self, key, value)
        setPropertyAndUpdate(self, key, value)
    end
})

------------------------------------------------
-- Triangle class
------------------------------------------------
local Triangle = {}
Triangle.__index = Triangle

function Triangle.new()
    local self = setmetatable(DrawingObject.new(), Triangle)

    -- Create the triangle using 3 frames to form a triangular shape
    self.frame = Instance.new("Frame")
    self.frame.AnchorPoint = Vector2.new(0.5, 0.5)
    self.frame.BorderSizePixel = 0
    self.frame.Parent = self.screenGui

    return self
end

function Triangle:update(changedProperty)
    -- Placeholder for proper triangle drawing logic. Currently using a frame.
    if self.properties.PointA and self.properties.PointB and self.properties.PointC then
        local midX = (self.properties.PointA.X + self.properties.PointB.X + self.properties.PointC.X) / 3
        local midY = (self.properties.PointA.Y + self.properties.PointB.Y + self.properties.PointC.Y) / 3
        self.frame.Size = UDim2.new(0, 100, 0, 100) -- Placeholder size
        self.frame.Position = UDim2.new(0, midX, 0, midY)
    end
    if self.properties.Transparency then
        self.frame.BackgroundTransparency = self.properties.Transparency
    end
end

setmetatable(Triangle, {
    __newindex = function(self, key, value)
        setPropertyAndUpdate(self, key, value)
    end
})

------------------------------------------------
-- CustomDrawing creation logic
------------------------------------------------
function CustomDrawing.new(drawType)
    if drawType == "Line" then
        return Line.new()
    elseif drawType == "Text" then
        return Text.new()
    elseif drawType == "Circle" then
        return Circle.new()
    elseif drawType == "Square" then
        return Square.new()
    elseif drawType == "Triangle" then
        return Triangle.new()
    else
        error("Invalid draw type: " .. tostring(drawType))
    end
end

return CustomDrawing
