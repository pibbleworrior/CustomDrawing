local CustomDrawing = {}
CustomDrawing.__index = CustomDrawing

local RunService = game:GetService("RunService")

-- Minimum time interval between updates (in seconds)
local MIN_UPDATE_INTERVAL = 0.05 -- 50 milliseconds

-- Helper function to get or create a ScreenGui in CoreGui
local function getOrCreateScreenGui()
    local CoreGui = game:GetService("CoreGui")
    local existingGui = CoreGui:FindFirstChild("CustomDrawingGui")
    
    if existingGui then
        return existingGui -- Reuse existing ScreenGui
    else
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "CustomDrawingGui"
        screenGui.Parent = CoreGui
        return screenGui
    end
end

-- CustomDrawing.new("Line")
function CustomDrawing.new(type)
    local self = setmetatable({}, CustomDrawing)

    -- Create or reuse a ScreenGui
    self.screenGui = getOrCreateScreenGui()

    -- Create a frame to represent the line
    if type == "Line" then
        self.frame = Instance.new("Frame")
        self.frame.AnchorPoint = Vector2.new(0.5, 0.5)
        self.frame.BorderSizePixel = 0  -- No border
        self.frame.Parent = self.screenGui

        -- Variables for throttling and debouncing
        self.isUpdated = false
        self.lastUpdateTime = 0  -- Keeps track of the last update time
        self.debounceTime = 0     -- Time to debounce rapid updates
        self.needsUpdate = false  -- Whether an update is pending

        return self
    else
        error("Unsupported drawing type: " .. tostring(type))
    end
end

-- Function to actually update the line's visual properties (throttled and debounced)
function CustomDrawing:updateLine()
    local currentTime = tick()

    -- Throttle updates to only happen after the minimum interval
    if currentTime - self.lastUpdateTime < MIN_UPDATE_INTERVAL then
        -- If it's too soon to update, mark as needing an update and debounce it
        self.needsUpdate = true
        return
    end

    -- Reset debounce flag
    self.needsUpdate = false

    -- Ensure that From and To are valid
    if not self.From or not self.To then
        warn("From or To is nil, skipping update.")
        return
    end

    -- Calculate the difference in X and Y coordinates
    local deltaX = self.To.X - self.From.X
    local deltaY = self.To.Y - self.From.Y
    local distance = math.sqrt(deltaX * deltaX + deltaY * deltaY)

    -- Calculate the midpoint between From and To
    local midX = (self.From.X + self.To.X) / 2
    local midY = (self.From.Y + self.To.Y) / 2

    -- Update the frame size, position, transparency, and rotation
    self.frame.Size = UDim2.new(0, distance, 0, self.Thickness)
    self.frame.Position = UDim2.new(0, midX, 0, midY)
    self.frame.Rotation = math.deg(math.atan2(deltaY, deltaX))
    self.frame.BackgroundTransparency = self.Transparency

    -- Update the last update time
    self.lastUpdateTime = currentTime

    -- Reset update flag after drawing
    self.isUpdated = false
end

-- Debounce handling for pending updates
function CustomDrawing:processPendingUpdates()
    if self.needsUpdate then
        self:updateLine()
    end
end

-- Setters to dynamically update properties (debounced to handle rapid changes)
function CustomDrawing:setFrom(point)
    if self.From ~= point then
        self.From = point
        self.isUpdated = true
        self:updateLine()
    end
end

function CustomDrawing:setTo(point)
    if self.To ~= point then
        self.To = point
        self.isUpdated = true
        self:updateLine()
    end
end

function CustomDrawing:setThickness(value)
    if self.Thickness ~= value then
        self.Thickness = value
        self.isUpdated = true
        self:updateLine()
    end
end

function CustomDrawing:setTransparency(value)
    if self.Transparency ~= value then
        self.Transparency = value
        self.isUpdated = true
        self:updateLine()
    end
end

-- Function to destroy the drawing
function CustomDrawing:destroy()
    if self.frame then
        self.frame:Destroy()
    end
end

-- Connect to RunService.Heartbeat to handle debouncing
RunService.Heartbeat:Connect(function()
    -- Check for any pending updates that need to be processed
    CustomDrawing:processPendingUpdates()
end)

return CustomDrawing
