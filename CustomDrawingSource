local CustomDrawing = {}
CustomDrawing.__index = CustomDrawing

-- Helper function to find or create the ScreenGui in CoreGui
local function getOrCreateScreenGui()
    local CoreGui = game:GetService("CoreGui")
    local existingGui = CoreGui:FindFirstChild("CustomDrawingGui")
    
    if existingGui then
        return existingGui  -- Reuse the existing ScreenGui
    else
        -- Create the ScreenGui
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "CustomDrawingGui"
        screenGui.Parent = CoreGui
        return screenGui
    end
end

-- CustomDrawing.new("Line")
function CustomDrawing.new(type)
    if type == "Line" then
        local self = setmetatable({}, CustomDrawing)

        -- Get or create the ScreenGui in CoreGui
        self.screenGui = getOrCreateScreenGui()

        -- Create the Frame to represent the line
        self.lineFrame = Instance.new("Frame")
        self.lineFrame.AnchorPoint = Vector2.new(0.5, 0.5)
        self.lineFrame.BorderSizePixel = 0
        self.lineFrame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)  -- Red color for visibility (can be changed)
        self.lineFrame.Parent = self.screenGui

        -- Initialize default properties
        self.Transparency = 0  -- Default fully opaque
        self.Thickness = 1     -- Default smallest thickness
        self.From = Vector2.new(0, 0) -- Default start point
        self.To = Vector2.new(100, 100) -- Default end point

        -- Draw the line based on the initial properties
        self:updateLine()

        return self
    else
        error("Unsupported drawing type: " .. tostring(type))
    end
end

-- Update the line based on its properties
function CustomDrawing:updateLine()
    -- Ensure that From and To are valid
    if not self.From or not self.To then
        warn("From or To is nil, skipping update.")
        return
    end

    -- Calculate the difference in X and Y coordinates
    local deltaX = self.To.X - self.From.X
    local deltaY = self.To.Y - self.From.Y
    local distance = math.sqrt(deltaX * deltaX + deltaY * deltaY)

    -- Update size, position, transparency, and rotation
    self.lineFrame.Size = UDim2.new(0, distance, 0, self.Thickness)
    self.lineFrame.Position = UDim2.new(0, (self.From.X + self.To.X) / 2, 0, (self.From.Y + self.To.Y) / 2)
    self.lineFrame.Rotation = math.deg(math.atan2(deltaY, deltaX))
    self.lineFrame.BackgroundTransparency = self.Transparency
end

-- Custom metatable to update properties dynamically when assigned
setmetatable(CustomDrawing, {
    __newindex = function(t, key, value)
        if key == "Transparency" then
            rawset(t, key, value)
            t:updateLine() -- Update when Transparency changes
        elseif key == "Thickness" then
            rawset(t, key, value)
            t:updateLine() -- Update when Thickness changes
        elseif key == "From" then
            -- Ensure 'From' is a valid Vector2
            if typeof(value) == "Vector2" then
                rawset(t, key, value)
                t:updateLine() -- Update when From changes
            else
                warn("Invalid value for 'From', must be Vector2")
            end
        elseif key == "To" then
            -- Ensure 'To' is a valid Vector2
            if typeof(value) == "Vector2" then
                rawset(t, key, value)
                t:updateLine() -- Update when To changes
            else
                warn("Invalid value for 'To', must be Vector2")
            end
        else
            rawset(t, key, value) -- Handle other properties
        end
    end
})

return CustomDrawing
